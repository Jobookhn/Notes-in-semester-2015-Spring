#2 Design and Development
##一、演变中的嵌入式系统软件开发技术
###1.微处理器技术
* 基于硅的半导体技术不断发展
* 不断复杂的应用需求
* 以RISC为代表的架构的流行
* 对软件的设计也产生了影响  
需要工具提供广泛、一致的支持，以及相关产品的细化和演化

带来的不是技术上的更替，而是更大的选择范围  
新的技术不代表对老技术的抛弃
###2.系统架构
* 单处理器+逻辑设备
* 更多集成设备  
芯片数量减少
####多处理器
* 功耗分布化
* 每个处理器实现特定的功能
* 对调试造成新的挑战
###3.设计的组合途径
* 早期，软件所占比例在5~10%左右  
硬件优先的设计阶段，整个软件相对简单  
以asm和C为主
* 后期的软件比重逐渐增加，从50%到70~的份额

软件的开发从单人方式逐渐演化出团队的形式，需要用更短的时间开发出更大、更复杂的软件，使得软件的测试工具产生了更高效的需求
####软件的内容
* 无OS
* 使用RTOS
* 增加中间件等其它可复用的软件组件

完全自己开发的代码比例在逐渐减少，外来部分的比重越来越大  
TTM的要求迫使我们使用外部引入的软件
###4.编程语言
####4/8位处理器时代
基本采用asm
####16位处理器时代
对高级语言的需求更加明显

* Pascal
* C  
针对嵌入式做出了相应的改变
####32位处理器时代
* C与Ada
* OO的优势使得C++的比例也有增长
* 设计和分析方面，2000年之后UML变得非常流行  
*搜索关键词：实时 UML*
###5.软件团队规模与分散
* 传统的单人专家模式  
也存在好处，问题很容易定位
* 每个人不可能熟悉所有范畴的内容，因此产生软件团队
* 使用C语言仍然需要每个人都知道一些系统的细节问题
* 可重用的软件组件需求
###6.UML与建模
* 良好的设计方法
* 可以被用于写代码的指导
* 也可以直接用于生成代码  
*然而生成的代码未必可用*  
使用这些代码存在争议，基于对资源高效使用的要求，性能未必足够地好
###7.关键技术
####微处理器技术
兼容的工具与RTOS产品
####系统架构
调试技术
####设计组件
* 指令集仿真器
* 基于宿主机的圆形
* 片上调试设备
* 软硬件协同验证
####软件内容
* 标准化的RTOS技术
* 调试技术
####变成语言
* C语言工具
* C++的产品
####团队的大小
* OOP
* 标准API的RTOS
##二、选择开发工具
###1.开发工具链
* 语言的常规交叉编译器
* 汇编器
* 链接器  
库
* 调试器
###2.编译器的特征
####接受的编程语言
* 是否兼容ANSI C？
* 是否兼容其它规范？
####提供的库
* 并不需要完整的运行时库
* C语言的库函数并没有定义为可重入的  
需要源代码来保证可重入性
* C++的类库支持
####支持完整的处理器家族
* 嵌入式设备变化较快，处理器的更改可能很频繁但变化都不大
* 升级成本最小的自然是在同系列处理器中选择  
代码的移植相对便捷
####制造商的支持
###3.嵌入式系统上的扩展
由于嵌入式编译器生成的代码对目标平台没有任何假设，因此需要额外的功能来解决这些复杂性

* 支持复杂的内存配置  
如静态变量的初始化策略
* 直接访问特定内存地址
* 内嵌汇编  
出于性能考虑，使用汇编语言可能是无法避免的  
使用高级语言，丢弃了对寄存器的控制能力  
这部分功能如果需要重新找回，就自然需要使用汇编
###4.实时系统的要求
* 中断  
特殊的`interrupt`关键字  
上下文的保存与恢复
* 可重入代码
* 存储布局  
`pack`与`unpack`关键字控制内存对齐  
存在空间与性能的平衡
* `volatile`关键字  
告知此变量的值可能被改变，编译器不进行任何优化  
很多编译器对此非标准关键字提供扩展支持
###5.优化
* 最终目标是优化的代码与人工编写的asm匹敌
* 一些优化可以不考虑处理器
* 但**指令调度**、**函数的内联**、**`switch`语句**等优化需要针对特定处理器进行
* 优化必须进行人为的精细控制
###6.构建工具的关键问题
* 对嵌入式系统的特殊需求提供广泛的支持
* 高标准的优化能力，支持用户对整个过程的干预
###7.调试工具的特征
####调试完全优化的代码
通常在初期对优化程度不高的代码进行调试，后期使用优化最大化的代码形式
####支持高层次操作
以适当的形式访问相应的代码和数据
####C++的额外需求
####脚本支持
给用户提供灵活的手段，使工具适应不同的应用
###8.开发阶段
* 初始阶段：硬件未定义  
在此阶段可以做一些算法和创意的尝试，以及软件工具的尝试
* 硬件被定义，但不可用  
硬件没有全部完成，可以做一些详细设计
* 硬件可用但不稳定  
提供了软硬件集成的机会
* 产品级的硬件可用  
可以进行完整的集成
* 系统发布  
软件已经过调优
####本地调试器
* 在宿主机中用宿主机的代码进行调试
* 在阶段1中有效  
验证算法和创意
* 如果与最终的嵌入式调试器UI相似，可以用来熟悉工具
* 在注重逻辑计算方面时，本地调试器会更加易用
####带有模拟器的调试器
* 在主机中模拟目标芯片指令的执行
* 在阶段2中有效
* 硬件配置已知，通过配置可以设定模拟器环境，加快开发进程
* 提供了详细的信息
* 需要支持中断和I/O
* 对性能分析和代码覆盖能提供很好的支持
####带ICE界面的在线仿真
* 很少使用
* 可以完整地定位问题，但目前做此类调试器的成本越来越高
* 成本和可用性抑制了它的发展
* 在阶段3中非常理想
####带监视器的调试器
* 需要稳定和全功能的硬件  
也就定义了在阶段4/5中使用
* 在目标机上使用
* 目标机上运行一个很小的监视程序  
期望此程序对机器的负载不产生任何影响
* 在最理想的情况下，监视程序也可以捆绑在程序中一起发布
* 成本最为低廉，*严格意义上*不能作为最终产品的完全模拟
####片上调试
* 需要额外的连接
* 如JTAG
####对RTOS的调试
* 要能感知断点
* 要访问特定实际任务的数据
* 要能访问中间状态
###9.调试工具的关键因素
* 是否允许完整优化的代码
* 工具提供对广泛执行环境的支持和选择
####其它选择因素
* 目标芯片
* 主机环境
* RTOS
###10.嵌入式软件与UML
####模型的不同含义
#####草图
* 很简单的记录，用于记录当时的想法
* 初步交流的方法
* 不需要完整，不需要进行维护
#####蓝图
* 构造计划书
* 反映出需要构建的事物
* 利用UML构建复杂的软件蓝图
* *蓝图很少被严格遵守*  
蓝图到实现的转换或多或少都会有一些转换
#####可执行原型
* 对系统行为以确定的方式进行了描述
* 不需要再与实际产物进行区别
####软件开发的演变
汇编->高级语言->UML

* 计算成本降低
* 系统复杂性越来越高
* 生产力提高  
高级语言转化为更多的低级语言

这也意味着抽象程度越来越高，系统的复杂性也越来越高
#####基于模型与基于代码的设计相比的优势
* 缺陷的发现时间被提前
* 有利于更好地进行开发
####基于蓝图的开发过程
* 利用UML构建分析模型
* 构建设计模型  
可能需要嵌入式系统的专门工具
* 从模型自动生成代码

*自动转换的代码难免令人产生怀疑，现阶段的使用范围十分有限，传统嵌入式开发工程师处于掌控欲的需要，可能对此难以接受*
####模型编译器
* 将UML转换到C/C++代码
* 不同的软件平台有不同的编译器  
共性部分可以复用
#####应用与架构分离
* 领域专家设计应用
* 嵌入式工程师设计地城架构
####术语表
（略）